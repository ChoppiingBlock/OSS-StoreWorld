## RandomAccessFile inputFile . read(byte b[], int off, int len) throws IOException  抛  IndexOutOfBoundsException

 IndexOutOfBoundsException – If off is negative, len is negative, or len is greater than b.length - off

抛这个异常是说off，len ， len 》 b.length - off



查看了半天bug，我就搞不明白，不就是off作为文件的偏移量吗？结果off是byte的偏移量，导致的OOB，在排查错误的过程中，我还看了一遍源码，还是没发现问题，最后复制粘贴并且梳理的时候，才发现人家注释写的清清楚楚，而我一厢情愿。



**心得**

今天主要完成的代码是枚举，错误类，把文件分块加载进入内存，合并输出。写代码比较慢。错误类需要打磨一下。写代码的时候思路不清晰，需要结合ai来帮助自己写代码。





## 往项目里面加入log4j2

配置半天了，无论怎么配置xml，都没有起到xml的效果。最后知道了。

1. 配置文件一般放resource
2. 如果插件内要引用配置好的xml，一定要在application.properties里面写好配置
3. 所有引用的插件，都要在application里面写。



![image-20240201181138561](C:\05program\bucketWorld\其他\调试bug\图片\image-20240201181138561.png)

实际上的buggersize >> bytesread 。 为什么byte最多就读了16k？

10 - 220000 7.1 三无

20 - 18w 2 



## 一:关于po、vo、dto的区别

在项目开发过程中，经常会碰到pojo、po、vo、dto的实体类，现在记录一下po、vo、dto的用法。
其中pojo是po、vo、dto的统称。
po、vo、dto都是实体类，其中po对应的是数据库的字段。DTO一般写在service层用来出参到门面层face（如果没有用门面的话一般都是直接用VO出参，有门面的话就是DTO再转成VO出参），VO则是你想给前端的字段，就是前端需要什么字段你VO就定义什么字段

PO
1.分辨PO实体类的有效方法是看其类上有没有加上注解@TableName或者，主键id有没有加 @TableId。有这个基本都是对应数据库的类，也就是PO。

2.po实体类大多需要调用CRUD的方法来获取数据库的值，或者把前端传进来的参数通过PO来存储到数据库中。

3.你也可以理解成po类字段对应的数据库的字段

4.不同项目的PO可能命名不同比如:他们可能放在entity、domain、po等包下

VO
vo里的实体类对应的大多是你页面上的一些字段，与数据库的实体类没啥关系，基本是给前端用的，常见的形式是类方法上有注解@ApiModel，私有属性@ApiModelProperty(value = “”），这两个注解基本都是为了方便前端知道他的作用给标明意思。

DTO
1.DTO类，多用于处理po和vo之间的关系，大致有时候也可以和vo相同。PO接收数据库的数据，然后转成DTO，DTO再转成VO（有时候为了偷懒，直接把DTO当成VO就不再转一层直接返回给前端）

这里给萌新们解释下什么是出参、入参
出参：就是返回的字段，意思就是你controller层最终要返回的字段，也就是前端需要的字段
入参：前端传给你的值，controller层方法接收字段。

## 关于Bean的获得和static，报错bean无法注入

背景，有一个流程控制函类allstream，需要在启动类中使用。但是启动类是static的。

无法@Autowired allstream ，然后调用里面的方法。

使用context方法会导致allstream里面的@Autowired fileStream 里面的@Autowired userservice失败。说是没有这个service。

解决方案：开个线程即可。但是疑问没有解决。为什么？



## 报错master.FeignClientSpecification被重复定义，但是我真的只定义了一次

报错：The bean 'master.FeignClientSpecification' could not be registered. A bean with that name has already been defined and overriding is disabled.

然后我csdn启用了可以重复定义bean。接着报错没有设置数据库，意识到是引入脏东西了。最后发现我的pom文件多了东西：

```
  <dependency>
            <groupId>com.spring</groupId>
            <artifactId>master</artifactId>
            <version>1.0-SNAPSHOT</version>
            <scope>compile</scope>
        </dependency>
```

## 构建失败controller说impl 缺少注入 ： 说mapper缺少注入：说baseMapper缺少。

报错，controller说impl 缺少注入 ： 说mapper缺少注入：说baseMapper缺少。

最后发现，是mybaits-plus需要在主类加扫描

## okhttp报错400

get请求，我构造的时候，把url都打印出来了，然后确实也是可以运行的，以为是head出错，结果不是。最后想到url的params里面因为有文件路径，需要特殊的编码方式处理。

### 



## 多线程报错文件流写入失败



```java
 在client，发送文件流，在写流的时候报错
 
 @GetMapping("/sendFile")
    public void sendFile(@RequestParam("path") String path ,
                                           @RequestParam("index") int index ,
                                           @RequestParam(value = "offset", defaultValue = "0") int offset,
                         HttpServletResponse response) throws IOException {

        Runnable sender = new Runnable() {
            @Override
            public void run() {
                try {
                    FileTransTool fileTransTool = new FileTransTool();
                    fileTransTool.sendFileStreamByPath(path, index, offset, response);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        taskExecutor.execute(sender);
    }

 OutputStream outputStream = new BufferedOutputStream(response.getOutputStream());
 。。。
outputStream.write(buffer, 0, fileLength);//报错行






Exception in thread "my-thread-1" java.lang.RuntimeException: org.apache.coyote.CloseNowException: Failed write
	at org.spring.controller.FileController$1.run(FileController.java:53)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: org.apache.coyote.CloseNowException: Failed write
	at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.doWrite(Http11OutputBuffer.java:540)
	at org.apache.coyote.http11.filters.ChunkedOutputFilter.doWrite(ChunkedOutputFilter.java:110)
	at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:190)
	at org.apache.coyote.Response.doWrite(Response.java:601)
	at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:339)
	at org.apache.catalina.connector.OutputBuffer.appendByteArray(OutputBuffer.java:746)
	at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:675)
	at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:386)
	at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:364)
	at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96)
	at java.base/java.io.BufferedOutputStream.write(BufferedOutputStream.java:123)
	at org.spring.tool.FileTransTool.sendFileStreamByPath(FileTransTool.java:235)
	at org.spring.controller.FileController$1.run(FileController.java:51)
	... 3 more
```

chat推测：是resopns被多线程操作了。线程不安全

但实际上，springboothttp请求是多线程的，respons是线程私有的，在方法内，outputstream也是线程私有的（new出来的）。在不加线程池的时候是ok的，不会报错



## 报奇怪错误未解决

![image-20240308165920360](C:\Users\flz\AppData\Roaming\Typora\typora-user-images\image-20240308165920360.png)
